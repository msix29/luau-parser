#[cfg(feature = "cache")]
use std::collections::HashMap;
#[cfg(not(feature = "cache"))]
use std::marker::PhantomData;

use tree_sitter::Node;
#[cfg(feature = "cache")]
use tree_sitter::Tree;

use crate::prelude::{Ast, AstNode, Token, TypeDefinition, VariableDeclaration};

fn print_all(node: Node, code: &str) {
    // if true {
    //     return;
    // }
    println!(
        "{:?}\n\t{}",
        node,
        &code[node.start_byte()..node.end_byte()]
    );

    for i in 0..node.child_count() {
        print_all(node.child(i).unwrap(), code);
    }
}

/// A Luau parser.
#[derive(Clone, Debug)]
pub struct Parser<'a> {
    #[cfg(feature = "cache")]
    cache: HashMap<String, (Ast<'a>, Tree)>,
    #[cfg(not(feature = "cache"))]
    _unused: PhantomData<Ast<'a>>,
}

impl Parser<'_> {
    pub fn new() -> Self {
        Parser {
            #[cfg(feature = "cache")]
            cache: HashMap::new(),
            #[cfg(not(feature = "cache"))]
            _unused: PhantomData {},
        }
    }

    /// Parses Luau code into an AST.
    pub fn parse(&mut self, code: &str, #[cfg(feature = "cache")] uri: &str) -> Ast<'_> {
        let mut parser = tree_sitter::Parser::new();
        parser
            .set_language(&tree_sitter_luau::language())
            .expect("Error loading Luau grammar");
        let tree = parser.parse(code, None).unwrap();

        let mut ast = Ast::default();
        let code_bytes = code.as_bytes();

        let root = tree.root_node();
        let mut cursor = tree.walk();
        for i in 0..root.child_count() {
            let node = root.child(i).unwrap();

            if let Some(mut variable_declarations) =
                VariableDeclaration::try_from_node(node, &mut cursor, code_bytes)
            {
                ast.tokens.extend(
                    variable_declarations
                        .iter_mut()
                        .map(|v| Token::VariableDeclaration(v.clone())),
                );
            } else if let Some(mut type_declarations) =
                TypeDefinition::try_from_node(node, &mut cursor, code_bytes)
            {
                ast.tokens.extend(
                    type_declarations
                        .iter_mut()
                        .map(|v| Token::TypeDefinition(v.clone())),
                );
            }
        }

        // TODO: Remove
        // For debugging purposes.
        if false {
            // Disabled for now, printing full tree may be enough.
            print_all(root, code);
        }
        println!("{}", &root.to_sexp());
        drop(cursor);

        #[cfg(feature = "cache")]
        {
            let uri = uri.to_string();
            self.cache.insert(uri.to_string(), (ast, tree));
            return self.cache.get(&uri).unwrap().0.to_owned();
        }

        #[cfg(not(feature = "cache"))]
        ast
    }

    /// Gets all ASTs generated by the parser
    #[cfg(feature = "cache")]
    pub fn get_all_asts(&self) -> HashMap<&String, &Ast<'_>> {
        self.cache
            .iter()
            .map(|(key, (ast, _))| (key, ast))
            .collect()
    }

    /// Clears the cache.
    #[cfg(feature = "cache")]
    pub fn clear_cache(&mut self) {
        self.cache.clear();
    }
}

impl Default for Parser<'_> {
    fn default() -> Self {
        Self::new()
    }
}
