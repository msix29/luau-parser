//! Implements helper traits for the _[parser](Parser)_.

#[cfg(feature = "cache")]
use std::collections::HashMap;
use std::sync::Arc;

use tree_sitter::Node;
#[cfg(feature = "cache")]
use tree_sitter::Tree;

use crate::prelude::{Ast, AstNode, DoBlock, ForIn, IfStatement, LocalAssignment, Token, TypeDefinition};

/// Parses a code block and fills `tokens` with the parsed ones. The tokens can then
/// be used to make the syntax tre.
pub(crate) fn parse_block(
    body: Node,
    tokens: &mut Vec<Token>,
    full_code_bytes: &[u8],
) -> Vec<Token> {
    let mut cursor = body.walk();
    for i in 0..body.child_count() {
        let node = body.child(i).unwrap();

        if let Some(variable_declaration) =
            LocalAssignment::try_from_node(node, &mut cursor, full_code_bytes)
        {
            tokens.push(Token::VariableDeclaration(variable_declaration));
        } else if let Some(type_declaration) =
            TypeDefinition::try_from_node(node, &mut cursor, full_code_bytes)
        {
            tokens.push(Token::TypeDefinition(type_declaration))
        } else if let Some(if_statement) =
            IfStatement::try_from_node(node, &mut cursor, full_code_bytes)
        {
            tokens.push(Token::IfStatement(if_statement))
        } else if let Some(do_block) = DoBlock::try_from_node(node, &mut cursor, full_code_bytes) {
            tokens.push(Token::DoBlock(do_block))
        } else if let Some(for_in) = ForIn::try_from_node(node, &mut cursor, full_code_bytes) {
            tokens.push(Token::ForIn(for_in))
        }
    }

    tokens.to_owned()
}

/// A Luau parser.
#[derive(Clone, Debug)]
pub struct Parser {
    /// Cache, only works with the `cache` feature, this increases speed of generation of
    /// ASTs after the first one.
    #[cfg(feature = "cache")]
    cache: HashMap<String, (Ast, Tree)>,
}

impl Parser {
    /// Create a new parser.
    pub fn new() -> Self {
        Parser {
            #[cfg(feature = "cache")]
            cache: HashMap::new(),
        }
    }

    /// Parse Luau code into an AST.
    pub fn parse(&mut self, code: &str, uri: &str) -> Ast {
        let mut parser = tree_sitter::Parser::new();
        parser
            .set_language(&tree_sitter_luau::language())
            .expect("Error loading Luau grammar");
        let tree = parser.parse(code, None).unwrap();

        let mut tokens = Vec::default();
        let code_bytes = code.as_bytes();

        let root = tree.root_node();
        // println!("\n{}\n", &root.to_sexp());
        parse_block(root, &mut tokens, code_bytes);

        let ast = Ast {
            tokens: Arc::new(tokens),
            uri: Some(uri.to_string()),
        };

        #[cfg(feature = "cache")]
        {
            let uri = uri.to_string();
            self.cache.insert(uri.to_string(), (ast, tree));

            return self.cache.get(&uri).unwrap().0.to_owned();
        }

        #[cfg(not(feature = "cache"))]
        {
            // Only start a new scope because clippy warnings.
            ast
        }
    }

    /// Get a specific ast from the cache, this function assumes the file does exist. If
    /// it may or may not exist, use [maybe_get_ast](Parser::maybe_get_ast)
    #[cfg(feature = "cache")]
    pub fn get_ast(&self, uri: &str) -> &Ast {
        &self.cache.get(uri).unwrap().0
    }

    /// Get a specific ast from the cache, this function is the safer version of
    /// [get_ast](Parser::get_ast).
    #[cfg(feature = "cache")]
    pub fn maybe_get_ast(&self, uri: &str) -> Option<&Ast> {
        self.cache.get(uri).map(|item| &item.0)
    }

    /// Get all ASTs generated by the parser
    #[cfg(feature = "cache")]
    pub fn get_all_asts(&self) -> HashMap<&String, &Ast> {
        self.cache
            .iter()
            .map(|(key, (ast, _))| (key, ast))
            .collect()
    }

    /// Clear the cache.
    #[cfg(feature = "cache")]
    pub fn clear_cache(&mut self) {
        self.cache.clear();
    }
}

impl Default for Parser {
    fn default() -> Self {
        Self::new()
    }
}
